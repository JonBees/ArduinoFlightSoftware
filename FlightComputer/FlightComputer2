#include <SD.h>
#include <Servo.h>
#include <SPI.h>

#define MAX_PACKET_SIZE 16

File myFile;
int millisNow = 0;
int millisLast = 0;
int SOFTKILLDECREMENT = 10;

Servo servoFrontLeft;//first value
Servo servoFrontRight;//second value
Servo servoBackLeft;
Servo servoBackRight;

int defaultValue[] = {1000,1000,1000,1000};
int currentValue[] = {1000,1000,1000,1000};
int numbers[] = {0,0,0,0};
int softKill[] = {1000,1000,1000,1000};

int MAX_MOTORS = 4;
int MAX_PWM = 4;
long int counter = 0;

int MICRO_STEPS = 100;

boolean start = false;
boolean failed = false;
boolean notStarted = true;
boolean softKillBool = false;

void setup()
{
  Serial.begin(9600);
 // Open Serial2 communications and wait for port to open:
  Serial2.begin(9600);
  servoFrontLeft.attach(3);//first value
  servoFrontRight.attach(4);//second value
  servoBackLeft.attach(5);
  servoBackRight.attach(6);


  Serial2.print("Initializing SD card...");
  // On the Ethernet Shield, CS is pin 4. It's set as an output by default.
  // Note that even if it's not used as the CS pin, the hardware SS pin 
  // (10 on most Arduino boards, 53 on the Mega) must be left as an output 
  // or the SD library functions will not work. 
   pinMode(53, OUTPUT);
   myFile = SD.open("PWMCOORD.TXT");
   delay(100);
   if (!SD.begin(53)){
     Serial2.print("YOU FUCKER");
     start = false;
   }
   myFile.close();
}

void loop()
{
  //read Serial2 data to know if we need to abort.
  if (Serial2.available()){
    char inByte = Serial2.read();
    if (inByte == 'a'){//abort
      start = false;
      Serial2.print("a");
      //myFile.close();
    }
    if (inByte == 'o'){//begin
      start = true;
      Serial2.print("o");
    }
    if (inByte == 'r'){//reset counter to beginning
      counter = 0;
      Serial2.print("r");
    }
    if (inByte == 's'){//softkill
      //do softkill here
      softKillBool = true;
      for (int j = 0; j < MAX_PWM; j++){
        softKill[j] = currentValue[j];
      } 
      Serial2.print("s"); 
    }
    if (inByte == 'p'){
       myFile = SD.open("PWMCOORD.TXT");
       Serial2.print("p:");
       while (myFile){
        Serial2.print(myFile.read());
       }
       Serial2.print(";");
    }
  }
  myFile = SD.open("PWMCOORD.TXT");
  //read file
  if (start){
    if (myFile){
      myFile.seek(counter);
      for (int i = 0; i < MAX_MOTORS; i++){
        for (int j = 0; j < MAX_PWM; j++){
          if (myFile.available()){
              char c = myFile.read();
              numbers[j] = c - '0';
              //Serial2.print(numbers[j]);
              counter++;
          }
          else{
            failed = true;
            Serial2.print("failed");
          }
        }
        //assign reads to four int
        currentValue[i] = (numbers[0]*1000) + (numbers[1]*100) + (numbers[2]*10) + (numbers[3]);
      }
    }
  }
  if ((!start) || (failed)) {
    for (int j = 0; j < MAX_PWM; j++){
      currentValue[j] = defaultValue[j];
    }
  }
  if (softKillBool){
    for (int j = 0; j < MAX_PWM; j++){
      currentValue[j] = softKill[j] - SOFTKILLDECREMENT;
      if (currentValue[j] < 1000){
        currentValue[j] = 1000;
        softKillBool = false;
      }
    }
  }
  millisNow = millis();
  //wait until time is right
  while (millisNow < (millisLast + MICRO_STEPS)){
    //do nothing
    millisNow = millis();
  }
  //assign now as last time
  millisLast = millisNow;
  //output to motors
  servoFrontLeft.writeMicroseconds(currentValue[0]);
  servoFrontRight.writeMicroseconds(currentValue[1]);
  servoBackLeft.writeMicroseconds(currentValue[2]);
  servoBackRight.writeMicroseconds(currentValue[3]);
  /*String packetToSend = "F:";
  packetToSend += String(currentValue[0]);
  packetToSend += String(",");
  packetToSend += String(currentValue[0]);
  packetToSend += String(",");
  packetToSend += String(currentValue[0]);
  packetToSend += String(",");
  packetToSend += String(currentValue[0]);
  packetToSend += String(";");
  Serial2.print(packetToSend);*/
  failed = false;
  myFile.close();
}
